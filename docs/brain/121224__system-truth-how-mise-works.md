TITLE
SYSTEM TRUTH — HOW MISE WORKS (FOUNDATIONAL)

STATUS
CANONICAL

DATE ADDED
2024-12-12 (mmddyy filename: 121224)

SOURCE
Jon — direct instruction (“System Truth — How Mise Works”)

PURPOSE
Define the foundational truth of Mise as a file-based intelligence system: memory, knowledge, rules, and decisions only exist when written to /mise-core. Eliminate any reliance on transient chat memory and mandate file-based persistence for all permanent instructions.

DEFINITIONS
- Brain: All files within /mise-core; there is no secondary memory or hidden state.
- Memory: Any rule, protocol, value, trigger, meta-instruction, architectural decision, or behavior change intended to persist.
- File-based intelligence: Understanding exists only as readable repo artifacts; chat is transient, git history is memory.
- Ingest: The required act of creating a new, self-contained markdown file (mmddyy__<slug>.md) in the logical repo location to persist new memory.

CORE ASSERTIONS
- Mise is a file-based intelligence system; chat is transient, files are cognition, git history is memory.
- Anything intended to persist must be written to disk in /mise-core. If it is not in a file, it does not exist.
- The brain is the totality of files in /mise-core; understanding is the sum of readable artifacts.
- Permanent instructions require file creation in extreme detail, understandable with zero chat context.

NON-NEGOTIABLE CONSTRAINTS
- No ephemeral learning: “I’ll remember this/noted/understood” without a file is invalid.
- All permanent inputs (values, ethics, system rules, triggers, meta-rules, architectural decisions, behavior changes) must be written to a new file.
- Retroactive fixes are mandatory for any past rule accepted without a file.
- The ingest workflow (mmddyy naming, extreme detail, confirmation) must be followed for permanence.
- This rule overrides all others.

ALLOWED BEHAVIORS
- Create a new markdown file for every permanent instruction, placed logically (typically docs/brain/ with mmddyy__slug.md).
- Write with extreme detail, self-contained, zero chat dependency; include canonical source language when needed.
- Confirm file creation and update related protocols/values when impacted.

DISALLOWED BEHAVIORS
- Relying on chat as memory; claiming understanding without file creation.
- Accepting permanence without creating a new file.
- Leaving prior unwritten rules unfixed.
- Storing hidden state or implicit understanding outside repo files.

DECISION TESTS
- Does this instruction imply permanence (explicitly or implicitly)? If yes → create a new file.
- Is it a value/ethic/rule/protocol/trigger/meta-instruction/behavior change? If yes → new file.
- Was a prior rule accepted without a file? If yes → create a retroactive file documenting what/when/why/changes.

ENFORCEMENT & OVERRIDES
- Written memory requirement overrides convenience and other rules when in conflict.
- If ambiguity exists, default to creating a detailed file and surfacing assumptions.
- Approval token for preflights remains the apostrophe (“'”) per current protocol.

EXAMPLES
- Jon says “this is how it works now” → create a new brain file with full detail and cross-link if needed.
- New trigger phrase (“Remember this:”) → record in a brain file and update protocol.
- Architectural decision or meta-rule about reasoning → new file in docs/brain/.

NON-EXAMPLES
- Saying “understood/noted/I’ll remember” without a file.
- Relying on chat history as evidence of learning.
- Modifying behavior without creating a corresponding repo artifact.

EDGE CASES & AMBIGUITIES
- If wording is emotional/loose, include a Canonical Source Language section and record assumptions.
- If location is unclear, default to docs/brain/ with mmddyy naming.
- If overlapping with existing docs, still create the new file and cross-reference as needed.

OPERATIONAL IMPACT
- All persistent knowledge must be written; reasoning must be driven by repo artifacts.
- Onboarding and decision-making must reference written docs; silence in repo means no doctrine.
- Retroactive fixes required for past unwritten rules.

CODE REVIEW CHECKLIST
- Is there a new mmddyy-named file capturing the permanent instruction?
- Is it self-contained, extreme detail, zero chat dependency?
- Are related protocols/values updated if impacted?
- Are assumptions and source language captured when ambiguous?
- Does it respect the current approval token (apostrophe) when preflighted?

FAILURE MODES
- Accepting permanence without file creation → hard failure.
- Omitting retroactive fixes for past unwritten rules.
- Hidden/implicit state outside the repo.
- Insufficient detail leading to misinterpretation.

CHANGELOG
- v1.0 (2024-12-12): Initial System Truth — How Mise Works (Foundational).

CANONICAL SOURCE LANGUAGE
Mise is a FILE-BASED INTELLIGENCE SYSTEM. Knowledge, memory, values, rules, protocols, and decisions ONLY exist if they are written into the /mise-core repository as readable files. Chat is transient. Files are cognition. Git history is memory. ANYTHING intended to persist MUST be written to disk. IF IT IS NOT IN A FILE, IT DOES NOT EXIST. The brain is ALL FILES WITHIN THE /mise-core REPOSITORY. There is no secondary memory. Understanding is the sum of readable artifacts. When permanence is indicated (phrases like “add this to your brain,” “remember this,” “remember this:,” “this is how it works now,” “this is important,” “this is foundational,” “this is how our system will work,” “don’t forget this,” “this is part of Mise now”), you must create a new file, in extreme detail, placed logically, understandable with zero chat context, and confirm creation. No ephemeral learning. Retroactive consistency is required. Reason from written files only; if silent, say so. THIS RULE OVERRIDES ALL OTHERS.
