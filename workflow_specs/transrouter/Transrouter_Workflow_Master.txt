# Mise TransRouter — Master Specification (Final Version)

## Overview

The **TransRouter** is the universal voice-to-intent engine for Mise.

It performs three core responsibilities:

1. **Audio Ingestion** — Receives raw audio directly from the user.  
2. **Transcription** — Converts that audio into clean, accurate natural-language text.  
3. **Interpretation & Routing** — Understands the meaning of the transcript and sends it to the correct domain agent (Payroll, Inventory, Scheduling, Ordering, General Assistant, etc.).

The TransRouter should behave like **NotebookLM’s podcast interaction layer**:  
It should feel like it *hears* the user, *understands* them deeply, and *responds intelligently*.

---

## 1. Audio Ingestion

The TransRouter receives raw audio data from the client application.

### Audio Input Contract

```jsonc
{
  "audio_bytes": "raw or base64-encoded audio",
  "audio_format": "wav | m4a | mp3 | webm",
  "sample_rate_hz": 16000,
  "user_id": "optional",
  "session_id": "optional",
  "source": "string identifying client",
  "timestamp": "ISO 8601"
}
This is the only entry point for spoken input into Mise.

2. Transcription

The TransRouter contains its own internal transcription layer.
Transcription does not happen anywhere else.

Transcription Output:
{
  "transcript": "clean natural-language text of the audio",
  "language_code": "optional string",
  "confidence": 0.0
}
The transcript must be fully normalized and suitable for semantic interpretation.

3. Interpretation (Intent, Domain, Entities)

After transcription, the TransRouter builds a TranscriptInput:
{
  "transcript": "string",
  "user_id": "optional",
  "session_id": "optional",
  "source": "client identifier",
  "timestamp": "ISO 8601"
}
The TransRouter then performs:

Intent classification

Domain agent selection

Entity extraction

Structured meaning derivation

This is where the TransRouter must behave like NotebookLM:
It interprets conversation-style speech, understands what the user is trying to do, and extracts operational meaning.

4. RoutingDecision

All interpretation results in a RoutingDecision object:
{
  "domain_agent": "payroll | inventory | scheduling | ordering | general_assistant",
  "intent_type": "string describing what the user wants",
  "entities": { },
  "raw_transcript": "string",
  "confidence": 0.0
}
This structure fully defines where the task should go.

5. Domain Delegation

The TransRouter converts the RoutingDecision into an AgentRequest:
{
  "domain_agent": "string",
  "routing_decision": { ... },
  "raw_transcript": "string",
  "user_id": "optional",
  "session_id": "optional",
  "timestamp": "ISO 8601"
}
The TransRouter calls:
handle_agent_request(request)
That domain agent returns an AgentResponse, and the TransRouter wraps it into:
{
  "status": "ok",
  "domain_agent": "string",
  "messages_for_user": [ "..." ],
  "outputs": { }
}
This is returned to the client.

6. Global Brain

The TransRouter maintains a unified global “brain” that contains:

Intent patterns

Domain routing rules

Entity schemas

Safety rules

Cloned mirrors of each domain agent’s brain folder

Directory Structure:
/brains
  /transrouter_brain
    core_rules.md
    domains_index.json
    intent_patterns.json
    entity_schemas.json
    safety_rules.md
    README.md

  /payroll_brain_clone
  /inventory_brain_clone
  /scheduling_brain_clone
  /ordering_brain_clone
Behavior:

Domain agents maintain canonical brains under /agents/.../brain/.

The TransRouter maintains clones under /brains/*_brain_clone/.

The TransRouter never modifies canonical domain brains.

This allows the TransRouter to “understand” every workflow at a semantic level.

7. Safety Requirements

Domain Boundaries

Payroll logic must not leak into inventory.

Inventory must not interfere with scheduling.

Ambiguity Handling
If interpretation is unclear:

Ask the user to clarify

Or route to general_assistant

Financial Sensitivity
Payroll-related interpretations must be especially strict and precise.

Structured Output
Entities must be extracted before any routing occurs.

Non-Destructive Behavior
The TransRouter never directly modifies domain data.

8. Implementation Architecture
Directory:
/transrouter/src/
  transrouter_orchestrator.py
  asr_adapter.py
  intent_classifier.py
  entity_extractor.py
  domain_router.py
  brain_sync.py
  schemas.py
  logging_utils.py
Core Pipeline Function
def handle_audio_request(audio_request: AudioRequest) -> RouterResponse:
    # 1. Transcribe the audio
    # 2. Build TranscriptInput
    # 3. Classify intent
    # 4. Extract entities
    # 5. Build RoutingDecision
    # 6. Call the correct domain agent
    # 7. Return RouterResponse

9. Non-Goals

The TransRouter does not:

Generate approval JSON files

Create PDFs or CSVs

Perform payroll math

Interpret inventory math

Run runners

Replace domain agents

Its sole mission is:

Transcribe → Understand → Route.
